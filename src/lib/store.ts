import { AppData, Encounter, Patient, Transcript, Note, NoteSection, ScheduleEvent } from "@/types";
import { createSeedData } from "./seed";

const STORAGE_KEY = "medscribe_data_v1";

let _data: AppData;

function load(): AppData {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) return JSON.parse(raw);
  } catch {}
  return createSeedData();
}

function save() {
  if (_data.settings.persistLocal) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(_data));
  }
}

export function initStore(): AppData {
  _data = load();
  return _data;
}

export function getData(): AppData {
  if (!_data) _data = load();
  return _data;
}

export function resetToSeed(): AppData {
  _data = createSeedData();
  save();
  return _data;
}

export function clearStorage() {
  localStorage.removeItem(STORAGE_KEY);
}

// --- Helpers ---
let _listeners: Array<() => void> = [];

export function subscribe(fn: () => void) {
  _listeners.push(fn);
  return () => { _listeners = _listeners.filter((l) => l !== fn); };
}

function notify() {
  save();
  _listeners.forEach((fn) => fn());
}

function uid(prefix: string) {
  return `${prefix}_${Date.now().toString(36)}`;
}

// --- Patients ---
export function addPatient(p: Omit<Patient, "id">): Patient {
  const patient = { id: uid("pat"), ...p };
  _data.patients.push(patient);
  notify();
  return patient;
}

export function updatePatient(id: string, updates: Partial<Patient>) {
  const i = _data.patients.findIndex((p) => p.id === id);
  if (i >= 0) { _data.patients[i] = { ..._data.patients[i], ...updates }; notify(); }
}

export function deletePatient(id: string) {
  _data.patients = _data.patients.filter((p) => p.id !== id);
  notify();
}

// --- Encounters ---
export function addEncounter(e: Omit<Encounter, "id">): Encounter {
  const enc = { id: uid("enc"), ...e };
  _data.encounters.push(enc);
  notify();
  return enc;
}

export function updateEncounter(id: string, updates: Partial<Encounter>) {
  const i = _data.encounters.findIndex((e) => e.id === id);
  if (i >= 0) { _data.encounters[i] = { ..._data.encounters[i], ...updates }; notify(); }
}

export function deleteEncounter(id: string) {
  _data.encounters = _data.encounters.filter((e) => e.id !== id);
  _data.transcripts = _data.transcripts.filter((t) => t.encounterId !== id);
  _data.notes = _data.notes.filter((n) => n.encounterId !== id);
  notify();
}

// --- Transcripts ---
export function addTranscript(t: Omit<Transcript, "id">): Transcript {
  const tr = { id: uid("tr"), ...t };
  _data.transcripts.push(tr);
  notify();
  return tr;
}

// --- Notes ---
export function addNote(n: Omit<Note, "id">): Note {
  const note = { id: uid("note"), ...n };
  _data.notes.push(note);
  notify();
  return note;
}

export function updateNoteSection(noteId: string, sectionId: string, content: string) {
  const note = _data.notes.find((n) => n.id === noteId);
  if (!note) return;
  const sec = note.sections.find((s) => s.id === sectionId);
  if (sec) {
    sec.content = content;
    sec.autoGenerated = false;
    sec.lastEditedAt = new Date().toISOString();
    notify();
  }
}

export function updateUnifiedNote(noteId: string, unifiedText: string) {
  const note = _data.notes.find((n) => n.id === noteId);
  if (!note) return;
  const blocks = unifiedText.split(/^## /m).filter(Boolean);
  const now = new Date().toISOString();
  blocks.forEach((block) => {
    const newlineIdx = block.indexOf("\n");
    if (newlineIdx === -1) return;
    const title = block.substring(0, newlineIdx).trim();
    const content = block.substring(newlineIdx + 1).trim();
    const sec = note.sections.find((s) => s.title === title);
    if (sec) {
      sec.content = content;
      sec.autoGenerated = false;
      sec.lastEditedAt = now;
    }
  });
  notify();
}

// --- Schedule Events ---
export function addScheduleEvent(e: Omit<ScheduleEvent, "id">): ScheduleEvent {
  const evt = { id: uid("sch"), ...e };
  if (!_data.scheduleEvents) _data.scheduleEvents = [];
  _data.scheduleEvents.push(evt);
  notify();
  return evt;
}

export function updateScheduleEvent(id: string, updates: Partial<ScheduleEvent>) {
  if (!_data.scheduleEvents) return;
  const i = _data.scheduleEvents.findIndex((e) => e.id === id);
  if (i >= 0) { _data.scheduleEvents[i] = { ..._data.scheduleEvents[i], ...updates }; notify(); }
}

export function deleteScheduleEvent(id: string) {
  if (!_data.scheduleEvents) return;
  _data.scheduleEvents = _data.scheduleEvents.filter((e) => e.id !== id);
  notify();
}

// --- Duplicate Encounter ---
export function duplicateEncounter(encId: string): Encounter | null {
  const enc = _data.encounters.find((e) => e.id === encId);
  if (!enc) return null;
  const now = new Date().toISOString();
  const newEnc: Encounter = {
    id: uid("enc"),
    patientId: enc.patientId,
    clinicianId: enc.clinicianId,
    startedAt: now,
    durationSec: 0,
    status: "draft",
    chiefComplaint: enc.chiefComplaint,
    location: enc.location,
  };
  _data.encounters.push(newEnc);

  // Duplicate note if exists
  const note = _data.notes.find((n) => n.id === enc.noteId);
  if (note) {
    const newNote = {
      id: uid("note"),
      encounterId: newEnc.id,
      templateId: note.templateId,
      sections: note.sections.map((s) => ({ ...s, id: uid("sec"), autoGenerated: false, lastEditedAt: now })),
    };
    _data.notes.push(newNote);
    newEnc.noteId = newNote.id;
  }

  notify();
  return newEnc;
}

// --- Settings ---
export function updateSettings(updates: Partial<AppData["settings"]>) {
  _data.settings = { ..._data.settings, ...updates };
  notify();
}
